package main

import (
	"fmt"
)

func main() {
	fmt.Println("START")

	fmt.Println("Output 1:", letterCombinations("23"), "\nExpected: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]")
	fmt.Println("Output 2:", letterCombinations(""), "\nExpected: []")
	fmt.Println("Output 3:", letterCombinations("2"), "\nExpected: [\"a\",\"b\",\"c\"]")

	fmt.Println("STOP")
}

/*
Constraints given by the problem:
	a. 0 <= digits.length <= 4
	b. digits[i] is a digit in the range ['2', '9'].
*/

// letterCombinations O(3n*4m) generates all possible letter combinations for a given string of digits.
func letterCombinations(digits string) []string {
	if len(digits) == 0 {
		return []string{}
	}

	numpad := map[string]string{
		"2": "abc",
		"3": "def",
		"4": "ghi",
		"5": "jkl",
		"6": "mno",
		"7": "pqrs",
		"8": "tuv",
		"9": "wxyz",
	}

	var combinations []string

	var backtrack func(index int, path string)
	backtrack = func(index int, path string) {
		if index == len(digits) {
			combinations = append(combinations, path)
			return
		}

		digit := string(digits[index])
		letters := numpad[digit]

		for i := 0; i < len(letters); i++ {
			backtrack(index+1, path+string(letters[i]))
		}
	}

	backtrack(0, "")

	return combinations
}

/*
Explanation of the function letterCombinations:

1. If the input string `digits` is empty, the function immediately returns an empty slice because there are no digits to process and hence no combinations to generate.
2. A map `numpad` is created to represent the traditional phone keypad, where each digit (from '2' to '9') maps to its corresponding letters.
3. An empty slice `combinations` is initialized to store all possible combinations of letters that will be generated by the function.
4. Recursive Backtracking Function:
	- A recursive function `backtrack` is defined to generate all possible combinations of letters. It takes two parameters:
		- `index`: The current position in the `digits` string.
		- `path`: The string built so far representing the current combination of letters.
	- Recursive Function Logic:
		- Base Case:** If `index` equals the length of `digits`, it means a complete combination has been formed. This combination is appended to the `combinations` slice, and the function returns.
		- Recursive Case:** For the current digit, the corresponding letters are retrieved from the `numpad` map. For each letter, the function recursively calls `backtrack` with the next index and an updated `path` that includes the current letter.
5. The `backtrack` function is initially called with `index` 0 and an empty `path` to start generating combinations from the beginning of the `digits` string.
6. After all recursive calls are completed and all possible combinations are generated, the function returns the `combinations` slice containing all letter combinations corresponding to the input digits.
*/
